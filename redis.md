### Redis 设计原则

存储效率。Redis 是专用于存储数据的，它对计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。这意味着 Redis 一定是非常精细地考虑了压缩数据、减少内存碎片等问题。

快速响应时间。与快速响应时间相对的，是高吞吐量。Redis 是用于提供在线访问的，对于单个请求的响应时间要求很高，因此，快速响应时间是比高吞吐量更重要的目标。

单线程。Redis 的性能瓶颈不在于 CPU 资源，而在于内存访问和网络 IO。而采用单线程的设计带来的好处是，极大简化了数据结构和算法的实现。相反，Redis 通过异步 IO 和 pipelining 等机制来实现高速的并发访问。显然，单线程的设计，对于单个请求的快速响应时间也提出了更高的要求。

### Redis 五大基本类型

1、String（字符串）

2、List（列表）

3、Set（无序集合）

4、 Sorted Set（有序集合）

5、Hash（哈希）

### 数据结构

**1、简单动态字符串（SDS）**

2、链表

3、字典

4、跳跃表

**5、整数集合**

6、压缩列表

7、对象

### SDS

Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组， 以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串 (simple dynamic string, SDS) 的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。

在Redis里面 ， C字符串只会作为字符串字面量(string literal)用在一些无须对字符串值进行修改的地方， 比如打印日志：

```
redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye... "}; 
```

当Redis需要的不仅仅是一个字符串字面量， 而是一个可以被修改的字符串值时， Redis就会使用SDS来表示字符串值 ， 比如在Redis的数据库里面， 包含字符串值的键值对在底层都是由SDS实现的 。

举个例子， 如果客户端执行命令：

```
redis> SET msg "hello world" 
OK 
```

那么 Redis 将在数据库中创建一个新的键值对， 其中：

□	键值对的键是一个字符串对象， 对象的底层实现是一个保存着字符串 "msg" 的SDS。
□	键值对的值也是一个字符串对象， 对象的底层实现是一个保存着字符串 "hello world" 的SDS。

又比如， 如果客户端执行命令：

```
redis> RPUSH fruits "apple" "banana" "cherry" 
(integer) 3 
```

- 键值对的键是一个字符串对象， 对象的底层实现是一个保存了字符串 "fruits" 的 SDS。
- 键值对的值是一个列表对象 ， 列表对象包含了三个字符串对象， 这三个字符串对象分别由三个 SDS 实现：第一个SDS 保存着字符串 "apple"， 第二个SOS保存着字符串 "banana", 第三个SDS保存着字符串 "cherry"。

#### 01、SDS 的定义

```
struct sdshdr { 
//记录buf数组中已使用字节的数量
//等于 SDS 所保存字符串的长度
int len; 

//记录buf数组中未使用字节的数量
int free; 
//字节数组， 用于保存字符串
char buf[]; 
); 
```

![image-20231028214446846](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028214446846.png)

上图展示了一个 SDS 示例：

- free 属性的值为 0，表示这个 SDS 没有分配任何未使用空间。
- len属性的值为 5，表示这个 SDS 保存了一个五字节长的字符串。
- buf属性是一个 char 类型的数组， 数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's' 五个字符， 而最后一个字节则保存了空字符 '\0'。

SDS遵循C字符串以空字符结尾的惯例， 保存空字符的1字节空间不计算在SDS的 len 属性里面， 并且为空字符分配额外的1字节空间， 以及添加空字符到字符串末尾等操作， 都是由SDS函数自动完成的， 所以这个空字符对千SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是， SDS可以直接重用一部分C字符串函数库里面的函数。

#### 02、与 C 语言传统字符串区别

##### 1）常数复杂度获取字符串长度

因为 C 字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的 复杂度为 O(N)。

和C 字符串不同，因为 SDS 在len属性中记录了 SDS本身的长度，所以获取一个 SDS 长度的复杂度仅为 0(1)。

##### 2）杜绝缓冲区溢出

除了获取字符串长度的复杂度高之外， C字符串不记录自身长度带来的另一个 问题是容易造成缓冲区溢出 (buffer overflow)。 举个例子， ＜string.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾：

```
char *strcat (char *dest, const char *src); 
```

因为 C字符串不记录自身的长度，所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳src 字符串中的所有内容， 而一旦这个假定不成立时，就会产生缓冲区溢出。

举个例子， 假设程序里有两个在内存中紧邻着的C字符串 s1 和 s2，其中 s1 保存了字符串"Redis"，s2 保存了字符串 "MongoDB"，如图所示。

![image-20231028221953716](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028221953716.png)

如果执行：

```
strcat(s1, " Cluster"); 
```

将 s1 的内容修改为 "Redis Cluster"， 但却忘了在执行strcat 之前为 s1 分配足够的空间， 那么在 strcat 函数执行之后， s1 的数据将溢出到 s2 所在的空间中，导致 s2 保存的内容被意外地修改，如图所示。

![image-20231028222129313](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028222129313.png)

与C字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API需要对 SDS 进行修改时， API会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会 **自动** 将 SDS 的空间 **扩展** 至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出问题 。

##### 3）减少修改字符串时带来的内存重分配次数

- 如果程序执行的是增长字符串的操作， 比如拼接操作(append)， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一 步就会产生缓冲区溢出。
- 如果程序执行的是缩短字符串的操作， 比如截断操作(trim)， 那么在执行这个操作之后 ， 程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了就会产生内存泄漏。

###### 1.  空间预分配

空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。

其中 ， 额外分配的未使用空间数量由以下公式决定：

- 如果对 SDS 进行修改之后，SDS的长度（也即是 len 属性的值）将小于 1MB，那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。举个例子，如果进行修改之后，SDS 的 len 将变成 13 字节，那么程序也会分配 13 字节的未使用空间，SDS 的 buf 数组的实际长度将变成 13+13+1 = 27字节（额外的一字节用于保存空字符）。
- 如果对 SDS 进行修改之后，SDS 的长度将大于等于 1MB，那么程序会分配 1MB 的未使用空间。举个例子，如果进行修改之后，SDS 的 len 将变成 30MB，那么程序会分配 1MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1MB + 1byte。通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。

```
sdscat(s, " Cluster"); 
```

![image-20231028224950129](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028224950129.png)

那么 sdscat 将执行次内存重分配操作， 将SDS的长度修改为 13 字节， 并将SDS的未使用空间同样修改为 13 字节。

![image-20231028225111476](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028225111476.png)

如果这时， 我们再次对s执行：

```
sdscat(s, " Tutorial"); 
```

那么这次 sdscat 将不需要执行内存重分配， 因为未使用空间里面的 13 字节足以保存 9 字节的" Tutorial"。

通过这种预分配策略， SDS将连续增长N次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。

###### 2．惰性空间释放

惰性空间释放用于优化SDS的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是**使用 free属性将这些字节的数量记录起来，并等待将来使用**。

与此同时，SDS也提供了相应的API，可以在有需要时真正地释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费。

##### 4）二进制安全

C字符串中的字符必须符合某种编码（比如ASCII)， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾， 这些限制使得C字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

举个例子， 如果有一种使用空字符来分割多个单词的特殊数据格式， 如图2-17所示，那么这种格式就不能使用C字符串来保存， 因为C字符串所用的函数只会识别出其中的"Redis"， 而忽略之后的“ Cluster"。

虽然数据库 般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此，为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是二进制安全的 (binary-safe)， 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、 过滤、 或者假设， 数据在写入时是什么样的， 它被读取时就是什么样。

这也是我们**将 SDS 的 buf 属性称为字节数组的原因，Redis 不是用这个数组来保存字符，而是用它来保存一系列二进制数据。**例如，使用SDS来保存之前提到的特殊数据格式就没有任何问题， 因为SDS使用len属性的值而不是空字符来判断字符串是否结束， 如图2-18所示。

##### 5） 兼容部分C字符串函数

虽然SDS的API都是二进制安全的， 但它们一样遵循C字符串以空字符结尾的惯例：这些 API 总会将 SDS 保存的数据的末尾设置为空字符，并且总会在为 buf 数组分配空间时多分配 个字节来容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h>库定义的函数。

举个例子，如果我们有一个保存文本数据的 SDS值 sds，那么就可以重用 <string.h>/strcasecmp 函数，使用它来对比 SDS 保存的字符串和另一个C字符串，这样 Redis 就不用自己专门去写一个函数来对比 SDS 值和 C 字符串值了。

通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用<string.h>函数库， 从而避免了不必要的代码重复。

### 整数集合

整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。

举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：

```bash
redis> SADD numbers 1 3 5 7 9
(integer) 5

redis> OBJECT ENCODING numbers
"intset"
```

当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。

而我们的整数集合（intset）可以做到使用较少的内存空间却达到和字典一样效率的实现，但前提是，集合中只能包含整型数据并且数量不能太多。整数集合最多能存多少个元素在 redis 中也是有体现的。

> OBJ_SET_MAX_INTSET_ENTRIES 512

也就是超过 **512** 个元素，或者向集合中添加了字符串或其他数据结构，redis 会将整数集合向字典结构进行转换。

#### 01、基本实现

整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。

每个 intset.h/intset 结构表示一个整数集合：

```cpp
typedef struct intset {

    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;
```

contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。

length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。

**虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值**：

- 如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 int16_t 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。
- 如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 int32_t 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。
- 如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 int64_t 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。

图示展示了一个整数集合示例：

![image-20231031212729065](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031212729065.png)

- encoding 属性的值为 INTSET_ENC_INT16 ， 表示整数集合的底层实现为 int16_t 类型的数组， 而集合保存的都是 int16_t 类型的整数值。
- length 属性的值为 5，表示整数集合包含五个元素。
- contents 数组按从小到大的顺序保存着集合中的五个元素。
- 因为每个集合元素都是 int16_t 类型的整数值， 所以 contents 数组的大小等于 sizeof(int16_t) * 5 = 16 * 5 = 80 位。

图示为另一个整数集合示例：

![image-20231031212927389](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031212927389.png)

- encoding 属性的值为 INTSET_ENC_INT64 ， 表示整数集合的底层实现为 int64_t 类型的数组， 而数组中保存的都是 int64_t 类型的整数值。
- length 属性的值为 4， 表示整数集合包含四个元素。
- contents 数组按从小到大的顺序保存着集合中的四个元素。
- 因为每个集合元素都是 int64_t 类型的整数值， 所以 contents 数组的大小为 sizeof(int64_t) * 4 = 64 * 4 = 256 位。

虽然 contents 数组保存的四个整数值中， 只有 -2675256175807981027 是真正需要用 int64_t 类型来保存的， 而其他的 1 、 3 、 5 三个值都可以用 int16_t 类型来保存， 不过根据整数集合的**升级**规则， 当向一个底层为 int16_t 数组的整数集合添加一个 int64_t 类型的整数值时， 整数集合已有的所有元素都会被转换成 int64_t 类型， 所以 contents 数组保存的四个整数值都是 int64_t 类型的， 不仅仅是 -2675256175807981027。

#### 02、升级

每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步进行：

1. 根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。
3. 将新元素添加到底层数组里面。

举个例子， 假设现在有一个 INTSET_ENC_INT16 编码的整数集合， 集合中包含三个 int16_t 类型的元素， 如图所示。

![image-20231031213546694](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031213546694.png)

因为每个元素都占用 16 位空间， 所以整数集合底层数组的大小为 3 * 16 = 48 位， 下图展示了整数集合的三个元素在这 48 位里的位置。

![image-20231031213623302](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031213623302.png)

现在， 假设我们要将类型为 int32_t 的整数值 65535 添加到整数集合里面， 因为 65535 的类型 int32_t 比整数集合当前所有元素的类型都要长， 所以在将 65535 添加到整数集合之前， 程序需要先对整数集合进行升级。

升级首先要做的是，根据新类型的长度，以及集合元素的数量（包括要添加的新元素在内），对底层数组进行空间重分配。

整数集合目前有三个元素， 再加上新元素 65535 ， 整数集合需要分配四个元素的空间， 因为每个 int32_t 整数值需要占用 32 位空间， 所以在空间重分配之后， 底层数组的大小将是 32 * 4 = 128 位， 如图所示。

![image-20231031213716117](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031213716117.png)

虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 1 、 2 、 3 仍然是 int16_t 类型， 这些元素还保存在数组的前 48 位里面， 所以程序接下来要做的就是将这三个元素转换成 int32_t 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。

![image-20231031213749947](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031213749947.png)

首先， 因为元素 3 在 1 、 2 、 3 、 65535 四个元素中排名第三， 所以它将被移动到 contents 数组的索引 2 位置上， 也即是数组 64 位至 95 位的空间内， 如图 所示。

![image-20231031213825521](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031213825521.png)

接着， 因为元素 2 在 1 、 2 、 3 、 65535 四个元素中排名第二， 所以它将被移动到 contents 数组的索引 1 位置上， 也即是数组的 32 位至 63 位的空间内，如图所示。

![image-20231031213910290](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031213910290.png)

之后， 因为元素 1 在 1 、 2 、 3 、 65535 四个元素中排名第一， 所以它将被移动到 contents 数组的索引 0 位置上， 也即是数组的 0 位至 31 位的空间内，如图 所示。

![image-20231031213953285](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031213953285.png)

然后， 因为元素 65535 在 1 、 2 、 3 、 65535 四个元素中排名第四， 所以它将被添加到 contents 数组的索引 3 位置上， 也即是数组的 96 位至 127 位的空间内， 如图所示。

![image-20231031214011503](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231031214011503.png)

最后， 程序将整数集合 encoding 属性的值从 INTSET_ENC_INT16 改为 INTSET_ENC_INT32 ， 并将 length 属性的值从 3 改为 4 ， 设置完成之后的整数集合如图所示。

**因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N)** 。

其他类型的升级操作， 比如从 INTSET_ENC_INT16 编码升级为 INTSET_ENC_INT64 编码， 或者从 INTSET_ENC_INT32 编码升级为 INTSET_ENC_INT64 编码， 升级的过程都和上面展示的升级过程类似。

> 升级之后新元素的摆放位置
> 因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：

- 在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；
- 在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。

##### 从较短整数到较长整数的转换，并不会更改元素里面的值。

  在 C 语言中，从长度较短的带符号整数到长度较长的带符号整数之间的转换（比如从 `int16_t` 转换为 `int32_t` ）总是可行的（不会溢出）、无损的。

  另一方面，从较长整数到较短整数之间的转换，可能是有损的（比如从 `int32_t` 转换为 `int16_t` ）。

  因为 intset 只进行从较短整数到较长整数的转换（也即是，只“升级”，不“降级”），因此，“升级”操作并不会修改元素原有的值。

#### 03、升级的好处

整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。

##### 提升灵活性

因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。

比如说， 我们一般只使用 int16_t 类型的数组来保存 int16_t 类型的值， 只使用 int32_t 类型的数组来保存 int32_t 类型的值， 诸如此类。

但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。

##### 节约内存

当然， 要让一个数组可以同时保存 int16_t 、int32_t 、int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 int16_t 类型或者 int32_t 类型的值， 数组都需要使用 int64_t 类型的空间去保存它们， 从而出现浪费内存的情况。

而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。

比如说， 如果我们一直只向整数集合添加 int16_t 类型的值， 那么整数集合的底层实现就会一直是 int16_t 类型的数组， 只有在我们要将 int32_t 类型或者 int64_t 类型的值添加到集合时， 程序才会对数组进行升级。

#### 04、降级

整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。

举个例子，即使将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了，整数集合的编码仍然会维持 INTSET_ENC_INT64 ，底层数组也仍然会是 int64_t 类型的。

Intset 定位为一种受限的中间表示， 只能保存整数值， 而且元素的个数也不能超过 `redis.h/REDIS_SET_MAX_INTSET_ENTRIES` （目前版本值为 `512` ） 这些条件决定了它被保存的时间不会太长， 因此没有必要进行太复杂的操作，

当然，如果内存确实十分紧张的话，给 intset 添加降级功能也是可以实现的，不过这可能会让 `intset` 的代码增长一倍。

#### 重点回顾

- 整数集合是集合键的底层实现之一。
- 整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。
- 升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。
- 整数集合只支持升级操作， 不支持降级操作。

https://juejin.cn/post/6844903974231883790