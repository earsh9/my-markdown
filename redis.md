## Redis 是什么？

Redis = Remote Dictionary Server，即远程字典服务

开源、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API

Redis可周期性将更新的数据写入磁盘或修改操作写入记录文件，并在此基础上实现master-slave（主-从）同步。

## Redis 五大基本类型

### 1、String（字符串）

### 2、List（列表）

### 3、Set（无序集合）

### 4、 Sorted Set（有序集合）

### 5、Hash（哈希）

## 数据结构

### 1、简单动态字符串（SDS）

Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组， 以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串 (simple dynamic string, SDS) 的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。

在Redis里面 ， C字符串只会作为字符串字面量(string literal)用在一些无须对字符串值进行修改的地方， 比如打印日志：

```
redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye... "}; 
```

当Redis需要的不仅仅是一个字符串字面量， 而是一个可以被修改的字符串值时， Redis就会使用SDS来表示字符串值 ， 比如在Redis的数据库里面， 包含字符串值的键值对在底层都是由SDS实现的 。

举个例子， 如果客户端执行命令：

```
redis> SET msg "hello world" 
OK 
```

那么 Redis 将在数据库中创建一个新的键值对， 其中：

□	键值对的键是一个字符串对象， 对象的底层实现是一个保存着字符串 "msg" 的SDS。
□	键值对的值也是一个字符串对象， 对象的底层实现是一个保存着字符串 "hello world" 的SDS。

又比如， 如果客户端执行命令：

```
redis> RPUSH fruits "apple" "banana" "cherry" 
(integer) 3 
```

- 键值对的键是一个字符串对象， 对象的底层实现是一个保存了字符串 "fruits" 的 SDS。
- 键值对的值是一个列表对象 ， 列表对象包含了三个字符串对象， 这三个字符串对象分别由三个 SDS 实现：第一个SDS 保存着字符串 "apple"， 第二个SOS保存着字符串 "banana", 第三个SDS保存着字符串 "cherry"。

#### 01、SDS 的定义

```
struct sdshdr { 
//记录buf数组中已使用字节的数量
//等于 SDS 所保存字符串的长度
int len; 

//记录buf数组中未使用宇节的数量
int free; 
//字节数组， 用于保存字符串
char buf[]; 
); 
```

![image-20231028214446846](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028214446846.png)

上图展示了一个 SDS 示例：

- free 属性的值为 0，表示这个 SDS 没有分配任何未使用空间。
- len属性的值为 5，表示这个 SDS 保存了一个五字节长的字符串。
- buf属性是一个 char 类型的数组， 数组的前五个字节分别保存了'R'、'e'、'd'、'i'、's' 五个字符， 而最后一个字节则保存了空字符 '\0'。

SDS遵循C字符串以空字符结尾的惯例， 保存空字符的1字节空间不计算在SDS的 len 属性里面， 并且为空字符分配额外的1字节空间， 以及添加空字符到字符串末尾等操作， 都是由SDS函数自动完成的， 所以这个空字符对千SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是， SDS可以直接重用一部分C字符串函数库里面的函数。

#### 02、与 C 语言传统字符串区别

##### 1）常数复杂度获取字符串长度

因为 C 字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度，程序必须遍历整个字符串，对遇到的每个字符进行计数，直到遇到代表字符串结尾的空字符为止，这个操作的 复杂度为 O(N)。

和C 字符串不同，因为 SDS 在len属性中记录了 SDS本身的长度，所以获取一个 SDS 长度的复杂度仅为 0(1)。

##### 2）杜绝缓冲区溢出

除了获取字符串长度的复杂度高之外， C字符串不记录自身长度带来的另一个 问题是容易造成缓冲区溢出 (buffer overflow)。 举个例子， ＜string.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾：

```
char *strcat (char *dest, const char *src); 
```

因为 C字符串不记录自身的长度，所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳src 字符串中的所有内容， 而一旦这个假定不成立时，就会产生缓冲区溢出。

举个例子， 假设程序里有两个在内存中紧邻着的C字符串 s1 和 s2，其中 s1 保存了字符串"Redis"，s2 保存了字符串 "MongoDB"，如图所示。

![image-20231028221953716](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028221953716.png)

如果执行：

```
strcat(s1, " Cluster"); 
```

将 s1 的内容修改为 "Redis Cluster"， 但却忘了在执行strcat 之前为 s1 分配足够的空间， 那么在 strcat 函数执行之后， s1 的数据将溢出到 s2 所在的空间中，导致 s2 保存的内容被意外地修改，如图所示。

![image-20231028222129313](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028222129313.png)

与C字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API需要对 SDS 进行修改时， API会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会 **自动** 将 SDS 的空间 **扩展** 至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出问题 。

##### 3）减少修改字符串时带来的内存重分配次数

- 如果程序执行的是增长字符串的操作， 比如拼接操作(append)， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一 步就会产生缓冲区溢出。
- 如果程序执行的是缩短字符串的操作， 比如截断操作(trim)， 那么在执行这个操作之后 ， 程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了就会产生内存泄漏。

###### 1.  空间预分配

空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。

其中 ， 额外分配的未使用空间数量由以下公式决定：

- 如果对 SDS 进行修改之后，SDS的长度（也即是 len 属性的值）将小于 1MB，那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。举个例子，如果进行修改之后，SDS 的 len 将变成 13 字节，那么程序也会分配 13 字节的未使用空间，SDS 的 buf 数组的实际长度将变成 13+13+1 = 27字节（额外的一字节用于保存空字符）。
- 如果对 SDS 进行修改之后，SDS 的长度将大于等于 1MB，那么程序会分配 1MB 的未使用空间。举个例子，如果进行修改之后，SDS 的 len 将变成 30MB，那么程序会分配 1MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1MB + 1byte。通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。

```
sdscat(s, " Cluster"); 
```

![image-20231028224950129](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028224950129.png)

那么 sdscat 将执行次内存重分配操作， 将SDS的长度修改为 13 字节， 并将SDS的未使用空间同样修改为 13 字节。

![image-20231028225111476](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028225111476.png)

如果这时， 我们再次对s执行：

```
sdscat(s, " Tutorial"); 
```

那么这次 sdscat 将不需要执行内存重分配， 因为未使用空间里面的 13 字节足以保存 9 字节的" Tutorial"。

通过这种预分配策略， SDS将连续增长N次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。

###### 2．惰性空间释放

惰性空间释放用于优化SDS的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是**使用 free属性将这些字节的数量记录起来，并等待将来使用**。

与此同时，SDS也提供了相应的API，可以在有需要时真正地释放SDS的未使用空间，不用担心惰性空间释放策略会造成内存浪费。

##### 4）二进制安全

C字符串中的字符必须符合某种编码（比如ASCII)， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾， 这些限制使得C字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

举个例子， 如果有一种使用空字符来分割多个单词的特殊数据格式， 如图2-17所示，那么这种格式就不能使用C字符串来保存， 因为C字符串所用的函数只会识别出其中的"Redis"， 而忽略之后的“ Cluster"。

虽然数据库 般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此，为了确保 Redis 可以适用于各种不同的使用场景，SDS 的 API 都是二进制安全的 (binary-safe)， 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、 过滤、 或者假设， 数据在写入时是什么样的， 它被读取时就是什么样。

这也是我们**将 SDS 的 buf 属性称为字节数组的原因，Redis 不是用这个数组来保存字符，而是用它来保存一系列二进制数据。**例如，使用SDS来保存之前提到的特殊数据格式就没有任何问题， 因为SDS使用len属性的值而不是空字符来判断字符串是否结束， 如图2-18所示。

##### 5） 兼容部分C字符串函数

虽然SDS的API都是二进制安全的， 但它们一样遵循C字符串以空字符结尾的惯例：这些 API 总会将 SDS 保存的数据的末尾设置为空字符，并且总会在为 buf 数组分配空间时多分配 个字节来容纳这个空字符，这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h>库定义的函数。

举个例子，如果我们有一个保存文本数据的 SDS值 sds，那么就可以重用 <string.h>/strcasecmp 函数，使用它来对比 SDS 保存的字符串和另一个C字符串，这样 Redis 就不用自己专门去写一个函数来对比 SDS 值和 C 字符串值了。

通过遵循 C 字符串以空字符结尾的惯例， SDS 可以在有需要时重用<string.h>函数库， 从而避免了不必要的代码重复。

### 2、链表

![image-20231028231006491](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028231006491.png)

多个 listNode 可以通过 prev 和 next 指针组成双端链表。

![image-20231028231145179](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028231145179.png)

![image-20231028231203383](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028231203383.png)

![image-20231028231217829](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028231217829.png)

由一个 list 结构和三个巨stNode 结构组成的链表：

![image-20231028231332269](C:\Users\zheng\AppData\Roaming\Typora\typora-user-images\image-20231028231332269.png)

Redis 的链表实现的特性可以总结如下：

- 双端：链表节点带有 prev 和 next 指针，获取某个节点的前置节点和后置节点的复杂度都是 O(1)。
- 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL，对链表的访问以 NULL 为终点。
- 带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针，获取链表的表头节点和表尾节点的复杂度为O(1)。
- 带链表长度计数器：程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数，获取链表中节点数量的复杂度为O(1)。
- 多态：链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup、free、match 三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

### 3、字典

### 4、跳跃表

### 5、整数集合

### 6、压缩列表

### 7、对象

